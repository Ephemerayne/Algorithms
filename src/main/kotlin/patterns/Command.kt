package patterns

/**
поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при
вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

Применимость
Когда вы хотите параметризовать объекты выполняемым действием.

Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов.

Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных
приложениях, не меняя каждый раз код ваших классов. Применив паттерн, пользователям не придётся изменять классы меню,
вместо этого они будут конфигурировать объекты меню различными командами.

Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.

Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку, чтобы потом сохранить в файл или
базу данных. Затем в любой удобный момент её можно достать обратно, снова превратить в объект команды и выполнить.
Таким же образом команды можно передавать по сети, логировать или выполнять на удалённом сервере.

Когда вам нужна операция отмены.

Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов,
которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.

История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением
операции сохраняет текущее состояние объекта, с которым она будет работать. После выполнения операции копия команды
попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт
последнюю команду из истории и возобновит сохранённое в ней состояние.

Этот способ имеет две особенности. Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может
быть приватным. Но с этим может помочь справиться паттерн Снимок.

Во-вторых, копии состояния могут занимать довольно много оперативной памяти. Поэтому иногда можно прибегнуть к
альтернативной реализации, когда вместо восстановления старого состояния команда выполняет обратное действие.
Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.
 */

interface ArithmeticCommand {
    fun execute(number: Int) : Int
}

class AddCommand(private val addendum: Int) : ArithmeticCommand {
    override fun execute(number: Int): Int {
        return number + addendum
    }
}

class MinusCommand(private val subtrahend: Int) : ArithmeticCommand {
    override fun execute(number: Int): Int {
        return number - subtrahend
    }
}

class MultiCommand(private val coefficient: Int) : ArithmeticCommand {
    override fun execute(number: Int): Int {
        return number * coefficient
    }
}