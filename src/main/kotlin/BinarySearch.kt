//  бинарный (двоичный) поиск
//  Его можно применять только на предварительно отсортированном массиве
// Самый простой алгоритм сортировки см. в статье Пузырьковая сортировка.
/* Суть бинарного поиска можно описать как «разделяй и властвуй». Исходный отсортированный по порядку массив мы делим
пополам и проверяем элемент посередине. Если он равен тому, который мы ищем, то возвращаем его индекс. Если не равен,
то проверяем границы и выбираем ту половину, в которой искомый элемент может находиться и выполняем проверку снова.
Так мы сужаем область поиска до тех пор, пока левая граница не станет равна правой. Если элемент не удалось найти,
возвращаем -1.
 */

/* Среди других алгоритмов сортировки «пузырьковая» является самой медленной. Однако при этом алгоритм достаточно прост
для понимания. На практике вместо него используют другие алгоритмы сортировки. Про пузырьковую сортировку любят
рассказывать при обучении программированию и любят спрашивать на собеседованиях.

Суть алгоритма заключается в том, что мы последовательно проходимся по массиву элементов, сравнивая текущий и
предыдущий между собой. Если предыдущий больше текущего, то меняем их местами. Таким образом, элемент с наибольшим
значением как бы «всплывает» в конец массива. Отсюда и название «пузырьковая сортировка».

На первой итерации в конце оказался наибольший элемент, однако надо отсортировать и другие.
Поэтому возвращаемся в начало и начинаем новую итерацию. То есть мы проходимся по массиву много раз.
Отсюда сложность алгоритма O(N^2), т.е. количество операций примерно равно количеству элементов массива в квадрате.
 */

fun main() {
    val array = intArrayOf(5, 2, 6, 7, 9, 1, 8, 4).sorted().toIntArray()
    // 1, 2, 4, 5, 6, 7, 8, 9
    val test = binarySearch(array, 4)
        println(test)
}

fun binarySearch(array: IntArray, targetValue: Int): Int {
    if (array.isEmpty()) return -1;

    var leftIndex = 0
    var rightIndex = array.lastIndex
    var iterationCount = 1

    while (leftIndex <= rightIndex) {
        val middle = (leftIndex + (rightIndex - leftIndex) / 2) // + 1 если нужен правый элемент из двух серединных

        println("left: $leftIndex")
        println("right: $rightIndex")
        println("middle: $middle")
        println("interations: $iterationCount")
        println("=======")

        if (array[middle] == targetValue) {
            return middle
        }

        if (array[middle] < targetValue) {
            leftIndex = middle + 1
        } else {
            rightIndex = middle - 1
        }

        iterationCount++

    }

    return -1
}