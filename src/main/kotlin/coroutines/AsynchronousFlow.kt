package coroutines

import kotlinx.coroutines.*
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.flow.*

/* Корутины позволяют возвращать одиночные значения. Для этого мы можем, к примеру, создавать корутину с помощью
построителя async. Но Kotlin также позволяет создавать асинхронные потоки (Asynchronous Flow), которые возвращают набор объектов.

В принципе для получения набора объектов мы могли бы в корутине возвращать коллекцию элементов, например, список List */

/* Для работы с потоками в Kotlin для интерфейса Flow определено ряд функций.
В зависимости от того, возвращают они конкретное значение или обработанный поток эти функции делятся на два вида:
терминальные функции и промежуточные функции. Рассмотрим основные из них.

Терминальные функции потоков
Терминальные функции потоков (terminal operators) представляют suspend-функции, которые позволяют непосредственно получать
объекты из потока или возвращают какое-то конечное значение:

collect(): получает из потока переданные значения

toList(): преобразует поток значений в коллекцию List

toSet(): преобразует поток значений в коллекцию Set

first() / firstOrNull(): получает первый объект из потока

last() / lastOrNull(): получает последний объект из потока

single() / singleOrNull(): ожидает получение одного объекта из потока
Функция single() возвращает единственный элемент потока, если поток содержит только один элемент.
Если поток не содержит элементов генерируется исключение NoSuchElementException, а если в потоке больше одного
элемента - исключение IllegalStateException.

count(): получает количество элементов в потоке
Также мы можем передать в функцию count() условие в виде функции, которая возвращает объект Boolean, то есть true или false.
Тогда функция count() возвратит количество элементов, которые соответствуют этому условию

reduce(): получает результат определенной операции над элементами потока
Оператор reduce сводит все значения потока к одному значению.
reduce принимает функцию, которая имеет два параметра. Первый параметр при первом запуске представляет первый объект
потока, а при последующих запусках - результат функции над предыдущими объектами. А второй параметр функции - следующий объект.

fold(): получает результат определенной операции над элементами потока, в отличие от функции reduce() принимает начальное значение
также сводит все элементы потока в один. Но в отличие от оператора reduce оператор fold в качестве первого параметра принимает начальное значение

Промежуточные функции
Промежуточные функции (Intermediate operator) принимают поток и возвращают обработанный поток.

combine(): объединяет два потока в один, после применения к их элементам функции преобразования

drop(): исключает из начала потока определенное количество значений и возвращает полученный поток
В качестве параметра она принимает количество элементов с начала потока, которые надо убрать из потока

filter(): фильтрует поток, оставляя те элементы, которые соответствуют условию
В качестве параметра он принимает функцию-условие, которая получает объект потока и возвращает true (если объект подходит фильтрацию)
и false (если не проходит)

filterNot(): фильтрует поток, оставляя те элементы, которые НЕ соответствуют условию

filterNotNull(): фильтрует поток, удаляя все элементы, которые равны null

Кроме того, Kotlin предоставляет еще ряд операций фильтрации для различных ситуаций:
1) takeWhile выбирает из потока элементы, пока будет истино некоторое условие
2) dropWhile противоположен по своему действию оператору takeWhile. dropWhile удаляет из потока элементы, пока они не
начнут соответствовать некоторому условию

map(): применяет к элементам потока фукцию преобразования
В качестве параметра он принимает функцию преобразования.
Функция преобразования принимает в качестве единственного параметра объект из потока и возвращает преобразованные данные.

onEach(): применяет к элементам потока определенную функцию перед тем, как они будут переданы в возвращаемый поток

take(): выбирает из потока определенное количество элементов
В качестве параметра она принимает количество элементов с начала потока, которые надо оставить в потоке

transform(): применяет к элементам потока функцию преобразования
В отличие от map она позволяет использовать функцию emit(), чтобы передавать в поток произвольные объекты.

zip(): из двух потоков создает один, применяя к их элементам функцию преобразования
позволяет объединить два потока данных
принимает два параметра. Первый параметр - поток данных, с которым надо выполнить объединение.
Второй параметр - собственно функция объединения. Она принимает соответствующие элементы обоих потоков в качестве
 параметров и возвращает результат их объединения.
 */

data class Car(
    val brand: String,
    val model: String,
    val price: Double,
    val color: String,
    val internalCompanyInfo: String,
) {
    val info = "$brand $model $price $color $internalCompanyInfo"

    fun saveToDb() {
        info
    }

    fun sendToCustomers() {
        info
    }
}


/*@OptIn(FlowPreview::class)
private suspend fun main() {



    *//*coroutineScope<Unit> {
    flowOfFunctionExample()*//*
    *//* launch {
         // getUsers().forEach { user -> println(user) }
         // getUsers2().collect { user -> println(user) }

         //getNumbers().collect { number -> println(number) }

         val numberFlow = getNumbers()       // поток создан, но не запущен
         println("numberFlow has created")
         println("launch collect function")
         numberFlow.collect { number -> println(number) }   // запуск потока
     }*//*
}*/

fun main() = runBlocking {
    val flow = flow {
        for (i in 1..1000) {
            emit(i)
        }
    }

    flow.buffer(100 ).onEach {
        delay(10) // имитация обработки элемента
        println("Received: $it")
    }.collect()
}

fun simpleFlow(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

private suspend fun getUsers(): List<String> {
    delay(1000L)  // имитация продолжительной работы
    return listOf("Tom", "Bob", "Sam")
}

/* Однако проблема таких коллекций в том, что они одномоментно возвращают все объекты.
Например, если в списке ожидается 1000 объектов, то соответственно пока функция getUsers() не возвратит список из
1000 объектов (например, получая их из базы данных или из внешнего интернет-ресурса), мы не сможем манипулировать объектами из этого списка.

Эту проблему в Kotlin как раз и позволяют решить асинхронные потоки. Изменим пример выше с применением асинхронных потоков: */

private fun getUsers2(): Flow<String> = flow<String> {
    val database = listOf("Tom", "Bob", "Sam", "Tom", "Bob", "Sam")  // условная база данных
    var i = 1
    for (item in database) {
        delay(400L) // имитация продолжительной работы
        println("Emit $i item")
        emit(item) // емитируем значение
        i++
    }
}

/* Для создания асинхронного потока данных применяется интерфейс Flow. То есть по сути асинхронный поток - это объект Flow.
Он типизируется типом тех данных, которые должны передаваться в потоке. В данном случае передаем строки, поэтому Flow типизируется типом String.

При этом при определении функции-потока (в данном случае функции getUsers) необязательно использовать модификатор suspend.

Для создания объекта Flow применяется специальная функция flow()

В самой функции в данном случае имитируется получение объектов из условной базы данных, коей здесь для простоты служит
список List. В цикле пробегаемся по этому списку и отправляем в поток текущий объект с помощью функции emit()


Это ключевой момент. Благодаря этому внешний код сможет получит переданное через emit() в поток значение и использовать его.

Для индикации номера отправляемого объекта я добавил переменную-счетчик i, которая увеличивается при переходе к другому
объекту списка. Вывод номера отправляемого объекта позволяет увидеть, что получение внешним кодом объектов из списка
происходит по мере его передачи в поток с помощью функции emit(), а не когда будут отправлены все объекты из списка.

Во внешнем коде в функции main вызываем функцию-поток getUsers(). Для управления объектами из потока для интерфейса
Flow определен ряд функций, одной из которых является функция collect(). В качестве параметра она принимает функцию, в
которую передает эмитируемый объект из потока. Так, в данном случае это просто функция вывода на консоль

Таким образом, программа не ждет, когда функция getUsers возвратит все строки. А получает строки по мере их отправки в
поток через функцию emit().
 */

private fun getNumbers(): Flow<Int> = flow {
    println("numberFlow has started")
    for (item in 1..5) {
        emit(item * item)
    }
}

/* Для создания асинхронного потока можно применять различные способы. Рассмотрим три основных способа.

Функция flow
Функция-построитель потока flow() позволяет задать логику передачи объектов в поток. Она может применяться как к
отдельной функции, так и сама по себе. Например, создание потока на базе функции:
 */

private suspend fun flowExample() {
    val numberFlow = getNumbers()
    numberFlow.collect { n -> println(n) }
}

// Определять поток в виде отдельной функции, как в примере выше, необязательно. Например:
private suspend fun flowExample2() {
    val userFlow = flow {
        val usersList = listOf("Tom", "Bob", "Sam")
        for (item in usersList) {
            emit(item)
        }
    }
    userFlow.collect { user -> println(user) }
}
// десь определена переменная userFlow, которая имеет тип Flow<String> и которая представляет поток,
// создаваемый построителем flow. В данном случае flow передает в поток объекты из списка строк.

// Функция flowOf
//Специальная функция-строитель flowOf() создает поток из набора переданных в функцию значений.

private suspend fun flowOfFunctionExample() {
    val numberFlow: Flow<Int> = flowOf(1, 2, 3, 5, 8)
    numberFlow.collect { n -> println(n) }
}

/* В данном случае в функцию построителя асинхронного потока flowOf() передается 5 значений типа Int,
поэтому создаваемый поток будет имет тип Flow<Int>. Все переданные значения будут автоматически эмитироваться в поток.
А получить их можно также как и в общем случае, например, через функцию collect().
 */

// Метод asFlow
//Стандартные коллекции и последовательности в Kotlin имеют метод расширения asFlow(), который позволяет преобразовать
// коллекцию или последовательность в поток:

private suspend fun asFlowFunctionExample() {
    // преобразование последовательности в поток
    val numberFlow: Flow<Int> = (1..5).asFlow()
    numberFlow.collect { n -> println(n) }

    // преобразование коллекции List<String> в поток
    val userFlow = listOf("Tom", "Sam", "Bob").asFlow()
    userFlow.collect { user -> println(user) }
}

/*
Задача: Список книг

Представьте, что у вас есть список книг, и вы хотите асинхронно получить их названия и авторов из разных источников
(например, базы данных и внешнего API). Вы хотите объединить эти данные и вывести на экран.

Вам нужно использовать Flow, чтобы асинхронно получить и объединить информацию о книгах. Вот как это может выглядеть:
 */

data class Book(val title: String, val author: String)

// Симуляция асинхронной загрузки книг из разных источников
suspend fun loadBooksFromDatabase(): List<Book> {
    delay(10000)
    return listOf(Book("Book 1", "Author 1"), Book("Book 2", "Author 2"))
}

suspend fun loadBooksFromApi(): List<Book> {
    delay(1500)
    return listOf(Book("Book 3", "Author 3"), Book("Book 4", "Author 4"))
}
/*
fun main() = runBlocking {
    val databaseFlow = flow { emit(loadBooksFromDatabase()) }
    val apiFlow = flow { emit(loadBooksFromApi()) }

    val combinedFlow: Flow<List<Book>> = merge(databaseFlow, apiFlow)

    val test = databaseFlow.zip(apiFlow) { book1, book2 ->
        mutableListOf<Book>().apply {
            addAll(book1)
            addAll(book2)
        }
    }

    test.collect {
        println("$it")
    }
   *//* combinedFlow.collect { books ->
        println("Received books: $books")
    }*//*
}*/

/*
В этом примере мы создаем два Flow, представляющих загрузку книг из базы данных и внешнего API. Затем мы объединяем
эти Flow с помощью функции merge, чтобы получить один общий Flow с данными о книгах. В итоге мы используем collect
для получения и вывода списка книг.
 */



