CoroutineScope
CoroutineScope — это основной компонент для управления корутинами в Kotlin.
Он предоставляет API для запуска и отмены корутин и позволяет определять, на каком потоке должны выполняться операции.
CoroutineScope также позволяет управлять жизненным циклом корутин и предотвращает утечки памяти.

CoroutineScope — это интерфейс, который предоставляет функции для запуска и управления корутинами.
Корутины запускаются внутри CoroutineScope, который определяет их жизненный цикл и контекст выполнения.

Примеры использования CoroutineScope в Android-разработке:

GlobalScope — это глобальный CoroutineScope, который может быть использован для запуска корутин в приложении.

Он не связан с жизненным циклом компонентов Android и продолжает выполнение корутин, даже если активность или
фрагмент были уничтожены.

Однако GlobalScope также имеет свои опасности, так как он не ограничен жизненным циклом и может привести к
утечкам памяти, если корутины не будут явно отменены или завершены.

viewModelScope — это CoroutineScope, связанный с жизненным циклом ViewModel.
Он автоматически отменяет все связанные с ним корутины при уничтожении ViewModel.

lifecycleScope является удобным способом создания CoroutineScope, связанного с жизненным циклом компонента
LifecycleOwner (например фрагмента или активности).

Преимуществом использования lifecycleScope является автоматическая отмена корутин.
Корутины, запущенные в lifecycleScope, автоматически отменяются при уничтожении фрагмента или активности.
Вам не нужно беспокоиться о явной отмене корутин: это происходит автоматически.

Вот пример использования lifecycleScope в корутинах:

class MyFragment : Fragment() {

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            // Код корутины
        }
    }

    // Остальной код фрагмента
}

CoroutineScope, созданный локально:

class MyFragment : Fragment() {

    private val myCoroutineScope = CoroutineScope(Dispatchers.Main)

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        myCoroutineScope.launch {
            // Код корутины
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        myCoroutineScope.cancel()
    }

    // Остальной код фрагмента
}
Обратите внимание, что при создании своего CoroutineScope вам необходимо самостоятельно отслеживать и отменять корутины.
Убедитесь, что вы правильно отменяете свой CoroutineScope, чтобы избежать утечек памяти и неправильного поведения вашего
приложения.

Использование собственного CoroutineScope особенно полезно, когда вам нужно управлять выполнением корутин в определенной
области или жизненном цикле вашего компонента.

Suspend
private suspend fun fetchUsers(): List<User> {
        return apiService.getUsers()
}
Ключевое слово suspend в Kotlin используется для обозначения функций, которые приостанавливают выполнение,
но не блокируют поток выполнения. В контексте Kotlin Coroutines это означает, что функции с пометкой suspend могут быть
приостановлены

в процессе своего выполнения и возобновлены позже без блокировки основного потока выполнения.

Функции, помеченные как suspend, могут выполнять длительные операции ввода-вывода или другие блокирующие операции,
не блокируя при этом основной поток выполнения. Вместо этого они могут приостанавливать свое выполнение и дать
возможность другим сопрограммам его продолжить.

Функции с ключевым словом suspend могут быть вызваны только из корутин или других функций с ключевым словом suspend.
Это делает код более безопасным и позволяет избежать проблем, связанных с блокировкой потоков.

Существует несколько встроенных диспетчеров, доступных в Kotlin.

Dispatchers.Main — это диспетчер, который используется для выполнения корутин в главном потоке Android.
Он должен применяться для всех операций, которые изменяют пользовательский интерфейс, таких как обновление View, Toast и т.д.

Dispatchers.IO — диспетчер, который используется для ввода-вывода (I/O) операций, таких как чтение или запись файлов,
сетевые операции и т.д. Он также имеет доступ к пулу потоков с несколькими потоками.

Dispatchers.Default — это диспетчер, который используется по умолчанию. Он предназначен для выполнения вычислительных
задач и имеет доступ к пулу потоков с несколькими потоками. Если вы не указываете явно диспетчер для корутины, она
будет выполнена на диспетчере Default.

Dispatchers.Unconfined — это диспетчер, который не ограничивает выполнение корутины каким-либо конкретным потоком.
Корутина будет продолжена на том же потоке, на котором была запущена. Этот диспетчер должен использоваться только в
очень ограниченном числе случаев, когда корутина может быть запущена и продолжена на любом потоке.